////////////////////////////////////////////////////////////////////////////////
// NOTE : Generated by slothjson. It is NOT supposed to modify this file.
////////////////////////////////////////////////////////////////////////////////
#include "AlgorithmUnitManage.h"

namespace slothjson {

alg_unit_t::alg_unit_t()
{
    unid = "";
    __skip_unid = false;
    __json_has_unid = false;

    refid = "";
    __skip_refid = false;
    __json_has_refid = false;

    cate = "traffic";
    __skip_cate = false;
    __json_has_cate = false;

    algid = "";
    __skip_algid = false;
    __json_has_algid = false;

    version = "";
    __skip_version = false;
    __json_has_version = false;

    name = "";
    __skip_name = false;
    __json_has_name = false;

    note = "traffic";
    __skip_note = false;
    __json_has_note = false;

    comb_pos = 1;
    __skip_comb_pos = false;
    __json_has_comb_pos = false;

    file_name = "";
    __skip_file_name = false;
    __json_has_file_name = false;

    upload_dt = "";
    __skip_upload_dt = false;
    __json_has_upload_dt = false;
}

alg_unit_t& alg_unit_t::operator=(const alg_unit_t& obj_val)
{
    this->unid = obj_val.unid;
    this->refid = obj_val.refid;
    this->cate = obj_val.cate;
    this->algid = obj_val.algid;
    this->version = obj_val.version;
    this->name = obj_val.name;
    this->note = obj_val.note;
    this->comb_pos = obj_val.comb_pos;
    this->file_name = obj_val.file_name;
    this->upload_dt = obj_val.upload_dt;
    return *this;
}

bool alg_unit_t::operator==(const alg_unit_t& obj_val) const
{
    if (!(this->unid == obj_val.unid)) return false;
    if (!(this->refid == obj_val.refid)) return false;
    if (!(this->cate == obj_val.cate)) return false;
    if (!(this->algid == obj_val.algid)) return false;
    if (!(this->version == obj_val.version)) return false;
    if (!(this->name == obj_val.name)) return false;
    if (!(this->note == obj_val.note)) return false;
    if (!(this->comb_pos == obj_val.comb_pos)) return false;
    if (!(this->file_name == obj_val.file_name)) return false;
    if (!(this->upload_dt == obj_val.upload_dt)) return false;
    return true;
}

bool alg_unit_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_unid && !slothjson_cxx::encode_field(unid, "unid", alloc, json_val)) break;
        if (!__skip_refid && !slothjson_cxx::encode_field(refid, "refid", alloc, json_val)) break;
        if (!__skip_cate && !slothjson_cxx::encode_field(cate, "cate", alloc, json_val)) break;
        if (!__skip_algid && !slothjson_cxx::encode_field(algid, "algid", alloc, json_val)) break;
        if (!__skip_version && !slothjson_cxx::encode_field(version, "version", alloc, json_val)) break;
        if (!__skip_name && !slothjson_cxx::encode_field(name, "name", alloc, json_val)) break;
        if (!__skip_note && !slothjson_cxx::encode_field(note, "note", alloc, json_val)) break;
        if (!__skip_comb_pos && !slothjson_cxx::encode_field(comb_pos, "comb_pos", alloc, json_val)) break;
        if (!__skip_file_name && !slothjson_cxx::encode_field(file_name, "file_name", alloc, json_val)) break;
        if (!__skip_upload_dt && !slothjson_cxx::encode_field(upload_dt, "upload_dt", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "unid", unid, __json_has_unid)) break;
        if (!slothjson_cxx::decode_field(json_val, "refid", refid, __json_has_refid)) break;
        if (!slothjson_cxx::decode_field(json_val, "cate", cate, __json_has_cate)) break;
        if (!slothjson_cxx::decode_field(json_val, "algid", algid, __json_has_algid)) break;
        if (!slothjson_cxx::decode_field(json_val, "version", version, __json_has_version)) break;
        if (!slothjson_cxx::decode_field(json_val, "name", name, __json_has_name)) break;
        if (!slothjson_cxx::decode_field(json_val, "note", note, __json_has_note)) break;
        if (!slothjson_cxx::decode_field(json_val, "comb_pos", comb_pos, __json_has_comb_pos)) break;
        if (!slothjson_cxx::decode_field(json_val, "file_name", file_name, __json_has_file_name)) break;
        if (!slothjson_cxx::decode_field(json_val, "upload_dt", upload_dt, __json_has_upload_dt)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

alg_unit_list_t::alg_unit_list_t()
{
    __skip_algo_list = false;
    __json_has_algo_list = false;
}

alg_unit_list_t& alg_unit_list_t::operator=(const alg_unit_list_t& obj_val)
{
    this->algo_list = obj_val.algo_list;
    return *this;
}

bool alg_unit_list_t::operator==(const alg_unit_list_t& obj_val) const
{
    if (!(this->algo_list == obj_val.algo_list)) return false;
    return true;
}

bool alg_unit_list_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_algo_list && !slothjson_cxx::encode_field(algo_list, "algo_list", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_list_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "algo_list", algo_list, __json_has_algo_list)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_list_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_list_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_list_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_list_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_list_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_list_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_list_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_list_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

alg_unit_get_list_response_t::alg_unit_get_list_response_t()
{
    err_code = 0;
    __skip_err_code = false;
    __json_has_err_code = false;

    err_msg = "";
    __skip_err_msg = false;
    __json_has_err_msg = false;

    cmd = "Command_Algorithm_Get_List";
    __skip_cmd = false;
    __json_has_cmd = false;

    __skip_algo_info = false;
    __json_has_algo_info = false;
}

alg_unit_get_list_response_t& alg_unit_get_list_response_t::operator=(const alg_unit_get_list_response_t& obj_val)
{
    this->err_code = obj_val.err_code;
    this->err_msg = obj_val.err_msg;
    this->cmd = obj_val.cmd;
    this->algo_info = obj_val.algo_info;
    return *this;
}

bool alg_unit_get_list_response_t::operator==(const alg_unit_get_list_response_t& obj_val) const
{
    if (!(this->err_code == obj_val.err_code)) return false;
    if (!(this->err_msg == obj_val.err_msg)) return false;
    if (!(this->cmd == obj_val.cmd)) return false;
    if (!(this->algo_info == obj_val.algo_info)) return false;
    return true;
}

bool alg_unit_get_list_response_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_err_code && !slothjson_cxx::encode_field(err_code, "err_code", alloc, json_val)) break;
        if (!__skip_err_msg && !slothjson_cxx::encode_field(err_msg, "err_msg", alloc, json_val)) break;
        if (!__skip_cmd && !slothjson_cxx::encode_field(cmd, "cmd", alloc, json_val)) break;
        if (!__skip_algo_info && !slothjson_cxx::encode_field(algo_info, "algo_info", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_get_list_response_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "err_code", err_code, __json_has_err_code)) break;
        if (!slothjson_cxx::decode_field(json_val, "err_msg", err_msg, __json_has_err_msg)) break;
        if (!slothjson_cxx::decode_field(json_val, "cmd", cmd, __json_has_cmd)) break;
        if (!slothjson_cxx::decode_field(json_val, "algo_info", algo_info, __json_has_algo_info)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_get_list_response_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_get_list_response_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_get_list_response_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_get_list_response_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_get_list_response_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_get_list_response_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_get_list_response_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_get_list_response_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

alg_unit_req_brief_t::alg_unit_req_brief_t()
{
    refid = "0";
    __skip_refid = false;
    __json_has_refid = false;

    cate = "";
    __skip_cate = false;
    __json_has_cate = false;
}

alg_unit_req_brief_t& alg_unit_req_brief_t::operator=(const alg_unit_req_brief_t& obj_val)
{
    this->refid = obj_val.refid;
    this->cate = obj_val.cate;
    return *this;
}

bool alg_unit_req_brief_t::operator==(const alg_unit_req_brief_t& obj_val) const
{
    if (!(this->refid == obj_val.refid)) return false;
    if (!(this->cate == obj_val.cate)) return false;
    return true;
}

bool alg_unit_req_brief_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_refid && !slothjson_cxx::encode_field(refid, "refid", alloc, json_val)) break;
        if (!__skip_cate && !slothjson_cxx::encode_field(cate, "cate", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_req_brief_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "refid", refid, __json_has_refid)) break;
        if (!slothjson_cxx::decode_field(json_val, "cate", cate, __json_has_cate)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_req_brief_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_req_brief_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_req_brief_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_req_brief_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_req_brief_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_req_brief_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_req_brief_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_req_brief_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

alg_unit_brief_req_msg_t::alg_unit_brief_req_msg_t()
{
    cmd = "Command_Algorithm_Srv_Get_Info";
    __skip_cmd = false;
    __json_has_cmd = false;

    __skip_algo_info = false;
    __json_has_algo_info = false;
}

alg_unit_brief_req_msg_t& alg_unit_brief_req_msg_t::operator=(const alg_unit_brief_req_msg_t& obj_val)
{
    this->cmd = obj_val.cmd;
    this->algo_info = obj_val.algo_info;
    return *this;
}

bool alg_unit_brief_req_msg_t::operator==(const alg_unit_brief_req_msg_t& obj_val) const
{
    if (!(this->cmd == obj_val.cmd)) return false;
    if (!(this->algo_info == obj_val.algo_info)) return false;
    return true;
}

bool alg_unit_brief_req_msg_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_cmd && !slothjson_cxx::encode_field(cmd, "cmd", alloc, json_val)) break;
        if (!__skip_algo_info && !slothjson_cxx::encode_field(algo_info, "algo_info", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_brief_req_msg_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "cmd", cmd, __json_has_cmd)) break;
        if (!slothjson_cxx::decode_field(json_val, "algo_info", algo_info, __json_has_algo_info)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_brief_req_msg_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_brief_req_msg_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_brief_req_msg_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_brief_req_msg_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_brief_req_msg_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_brief_req_msg_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_brief_req_msg_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_brief_req_msg_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

alg_unit_brief_request_t::alg_unit_brief_request_t()
{
    __skip_request = false;
    __json_has_request = false;
}

alg_unit_brief_request_t& alg_unit_brief_request_t::operator=(const alg_unit_brief_request_t& obj_val)
{
    this->request = obj_val.request;
    return *this;
}

bool alg_unit_brief_request_t::operator==(const alg_unit_brief_request_t& obj_val) const
{
    if (!(this->request == obj_val.request)) return false;
    return true;
}

bool alg_unit_brief_request_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_request && !slothjson_cxx::encode_field(request, "request", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_brief_request_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "request", request, __json_has_request)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_brief_request_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_brief_request_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_brief_request_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_brief_request_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_brief_request_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_brief_request_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_brief_request_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_brief_request_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

alg_unit_list_info_t::alg_unit_list_info_t()
{
    __skip_algo_info = false;
    __json_has_algo_info = false;
}

alg_unit_list_info_t& alg_unit_list_info_t::operator=(const alg_unit_list_info_t& obj_val)
{
    this->algo_info = obj_val.algo_info;
    return *this;
}

bool alg_unit_list_info_t::operator==(const alg_unit_list_info_t& obj_val) const
{
    if (!(this->algo_info == obj_val.algo_info)) return false;
    return true;
}

bool alg_unit_list_info_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_algo_info && !slothjson_cxx::encode_field(algo_info, "algo_info", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_list_info_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "algo_info", algo_info, __json_has_algo_info)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_list_info_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_list_info_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_list_info_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_list_info_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_list_info_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_list_info_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_list_info_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_list_info_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

alg_unit_brief_response_t::alg_unit_brief_response_t()
{
    err_code = 0;
    __skip_err_code = false;
    __json_has_err_code = false;

    err_msg = "";
    __skip_err_msg = false;
    __json_has_err_msg = false;

    cmd = "Command_Algorithm_Get_List";
    __skip_cmd = false;
    __json_has_cmd = false;

    __skip_response = false;
    __json_has_response = false;
}

alg_unit_brief_response_t& alg_unit_brief_response_t::operator=(const alg_unit_brief_response_t& obj_val)
{
    this->err_code = obj_val.err_code;
    this->err_msg = obj_val.err_msg;
    this->cmd = obj_val.cmd;
    this->response = obj_val.response;
    return *this;
}

bool alg_unit_brief_response_t::operator==(const alg_unit_brief_response_t& obj_val) const
{
    if (!(this->err_code == obj_val.err_code)) return false;
    if (!(this->err_msg == obj_val.err_msg)) return false;
    if (!(this->cmd == obj_val.cmd)) return false;
    if (!(this->response == obj_val.response)) return false;
    return true;
}

bool alg_unit_brief_response_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_err_code && !slothjson_cxx::encode_field(err_code, "err_code", alloc, json_val)) break;
        if (!__skip_err_msg && !slothjson_cxx::encode_field(err_msg, "err_msg", alloc, json_val)) break;
        if (!__skip_cmd && !slothjson_cxx::encode_field(cmd, "cmd", alloc, json_val)) break;
        if (!__skip_response && !slothjson_cxx::encode_field(response, "response", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_brief_response_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "err_code", err_code, __json_has_err_code)) break;
        if (!slothjson_cxx::decode_field(json_val, "err_msg", err_msg, __json_has_err_msg)) break;
        if (!slothjson_cxx::decode_field(json_val, "cmd", cmd, __json_has_cmd)) break;
        if (!slothjson_cxx::decode_field(json_val, "response", response, __json_has_response)) break;

        return true;
    } while (0);

    return false;
}

bool alg_unit_brief_response_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool alg_unit_brief_response_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const alg_unit_brief_response_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, alg_unit_brief_response_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<alg_unit_brief_response_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<alg_unit_brief_response_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<alg_unit_brief_response_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<alg_unit_brief_response_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

server_ip_vector_t::server_ip_vector_t()
{
    __skip_server_ip = false;
    __json_has_server_ip = false;
}

server_ip_vector_t& server_ip_vector_t::operator=(const server_ip_vector_t& obj_val)
{
    this->server_ip = obj_val.server_ip;
    return *this;
}

bool server_ip_vector_t::operator==(const server_ip_vector_t& obj_val) const
{
    if (!(this->server_ip == obj_val.server_ip)) return false;
    return true;
}

bool server_ip_vector_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_server_ip && !slothjson_cxx::encode_field(server_ip, "server_ip", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool server_ip_vector_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "server_ip", server_ip, __json_has_server_ip)) break;

        return true;
    } while (0);

    return false;
}

bool server_ip_vector_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool server_ip_vector_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const server_ip_vector_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, server_ip_vector_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<server_ip_vector_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<server_ip_vector_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<server_ip_vector_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<server_ip_vector_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

server_ip_list_response_t::server_ip_list_response_t()
{
    err_code = 0;
    __skip_err_code = false;
    __json_has_err_code = false;

    err_msg = "";
    __skip_err_msg = false;
    __json_has_err_msg = false;

    cmd = "Command_Algorithm_Srv_Get_IP_List";
    __skip_cmd = false;
    __json_has_cmd = false;

    __skip_response = false;
    __json_has_response = false;
}

server_ip_list_response_t& server_ip_list_response_t::operator=(const server_ip_list_response_t& obj_val)
{
    this->err_code = obj_val.err_code;
    this->err_msg = obj_val.err_msg;
    this->cmd = obj_val.cmd;
    this->response = obj_val.response;
    return *this;
}

bool server_ip_list_response_t::operator==(const server_ip_list_response_t& obj_val) const
{
    if (!(this->err_code == obj_val.err_code)) return false;
    if (!(this->err_msg == obj_val.err_msg)) return false;
    if (!(this->cmd == obj_val.cmd)) return false;
    if (!(this->response == obj_val.response)) return false;
    return true;
}

bool server_ip_list_response_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_err_code && !slothjson_cxx::encode_field(err_code, "err_code", alloc, json_val)) break;
        if (!__skip_err_msg && !slothjson_cxx::encode_field(err_msg, "err_msg", alloc, json_val)) break;
        if (!__skip_cmd && !slothjson_cxx::encode_field(cmd, "cmd", alloc, json_val)) break;
        if (!__skip_response && !slothjson_cxx::encode_field(response, "response", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool server_ip_list_response_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "err_code", err_code, __json_has_err_code)) break;
        if (!slothjson_cxx::decode_field(json_val, "err_msg", err_msg, __json_has_err_msg)) break;
        if (!slothjson_cxx::decode_field(json_val, "cmd", cmd, __json_has_cmd)) break;
        if (!slothjson_cxx::decode_field(json_val, "response", response, __json_has_response)) break;

        return true;
    } while (0);

    return false;
}

bool server_ip_list_response_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool server_ip_list_response_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const server_ip_list_response_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, server_ip_list_response_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<server_ip_list_response_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<server_ip_list_response_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<server_ip_list_response_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<server_ip_list_response_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

parent_server_t::parent_server_t()
{
    __skip_ip = false;
    __json_has_ip = false;

    __skip_serial_num = false;
    __json_has_serial_num = false;
}

parent_server_t& parent_server_t::operator=(const parent_server_t& obj_val)
{
    this->ip = obj_val.ip;
    this->serial_num = obj_val.serial_num;
    return *this;
}

bool parent_server_t::operator==(const parent_server_t& obj_val) const
{
    if (!(this->ip == obj_val.ip)) return false;
    if (!(this->serial_num == obj_val.serial_num)) return false;
    return true;
}

bool parent_server_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_ip && !slothjson_cxx::encode_field(ip, "ip", alloc, json_val)) break;
        if (!__skip_serial_num && !slothjson_cxx::encode_field(serial_num, "serial_num", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool parent_server_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "ip", ip, __json_has_ip)) break;
        if (!slothjson_cxx::decode_field(json_val, "serial_num", serial_num, __json_has_serial_num)) break;

        return true;
    } while (0);

    return false;
}

bool parent_server_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool parent_server_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const parent_server_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, parent_server_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<parent_server_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<parent_server_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<parent_server_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<parent_server_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

parent_server_response_t::parent_server_response_t()
{
    err_code = 0;
    __skip_err_code = false;
    __json_has_err_code = false;

    err_msg = "";
    __skip_err_msg = false;
    __json_has_err_msg = false;

    cmd = "Command_Algorithm_Srv_Get_Parent_Server";
    __skip_cmd = false;
    __json_has_cmd = false;

    __skip_response = false;
    __json_has_response = false;
}

parent_server_response_t& parent_server_response_t::operator=(const parent_server_response_t& obj_val)
{
    this->err_code = obj_val.err_code;
    this->err_msg = obj_val.err_msg;
    this->cmd = obj_val.cmd;
    this->response = obj_val.response;
    return *this;
}

bool parent_server_response_t::operator==(const parent_server_response_t& obj_val) const
{
    if (!(this->err_code == obj_val.err_code)) return false;
    if (!(this->err_msg == obj_val.err_msg)) return false;
    if (!(this->cmd == obj_val.cmd)) return false;
    if (!(this->response == obj_val.response)) return false;
    return true;
}

bool parent_server_response_t::encode(allocator_t& alloc, rapidjson::Value& json_val) const
{
    do
    {
        json_val.SetObject();
        if (!__skip_err_code && !slothjson_cxx::encode_field(err_code, "err_code", alloc, json_val)) break;
        if (!__skip_err_msg && !slothjson_cxx::encode_field(err_msg, "err_msg", alloc, json_val)) break;
        if (!__skip_cmd && !slothjson_cxx::encode_field(cmd, "cmd", alloc, json_val)) break;
        if (!__skip_response && !slothjson_cxx::encode_field(response, "response", alloc, json_val)) break;

        return true;
    } while (0);

    return false;
}

bool parent_server_response_t::decode(const rapidjson::Value& json_val)
{
    do
    {
        if (!slothjson_cxx::decode_field(json_val, "err_code", err_code, __json_has_err_code)) break;
        if (!slothjson_cxx::decode_field(json_val, "err_msg", err_msg, __json_has_err_msg)) break;
        if (!slothjson_cxx::decode_field(json_val, "cmd", cmd, __json_has_cmd)) break;
        if (!slothjson_cxx::decode_field(json_val, "response", response, __json_has_response)) break;

        return true;
    } while (0);

    return false;
}

bool parent_server_response_t::encode_to_string(std::string& json_str) const
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = encode(json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool parent_server_response_t::decode_from_string(const std::string& json_str)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
					return decode(json_doc);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
				<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

bool encode(const parent_server_response_t& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return obj_val.encode(alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, parent_server_response_t& obj_val)
{
    return obj_val.decode(json_val);
}

bool encode(const std::vector<parent_server_response_t>& obj_val, allocator_t& alloc, rapidjson::Value& json_val)
{
    return slothjson_cxx::encode(obj_val,alloc, json_val);
}

bool decode(const rapidjson::Value& json_val, std::vector<parent_server_response_t>& obj_val)
{
    return slothjson_cxx::decode(json_val,obj_val);
}

bool encode(const  std::vector<parent_server_response_t>& obj_val,std::string& json_str)
{
	bool status = false;
	rapidjson::Value json_val;
	rapidjson::Document json_doc;
	rapidjson::Document::AllocatorType& json_alloc = json_doc.GetAllocator();
	status = slothjson_cxx::encode(obj_val,json_alloc,json_doc);
	rapidjson::StringBuffer buffer;
	rapidjson::Writer<rapidjson::StringBuffer> writer(buffer);
	json_doc.Accept(writer);
	json_str = buffer.GetString();
	return status;
}

bool decode(const std::string& json_str, std::vector<parent_server_response_t>& obj_val)
{
	try
	{
		rapidjson::Document json_doc;
		if(!(json_doc.Parse<0>(json_str.c_str()).HasParseError()))
		{
			return slothjson_cxx::decode(json_doc,obj_val);
		}
		else
		{
			std::cout<<"parse error:"<< json_doc.GetParseError()<< json_doc.GetErrorOffset()
					<<rapidjson::GetParseError_En(json_doc.GetParseError())<<std::endl;
		}
	}
	catch(std::exception e)
	{
		std::cout<<e.what()<<std::endl;
	}
	return false;
}

} // namespace slothjson